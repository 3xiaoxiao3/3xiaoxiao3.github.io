<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/11/hello-world/</url>
    <content><![CDATA[<h1 id="KEEP-THINKING-KEEP-CODING"><a href="#KEEP-THINKING-KEEP-CODING" class="headerlink" title="KEEP THINKING ,KEEP CODING"></a>KEEP THINKING ,KEEP CODING</h1>]]></content>
      <categories>
        <category>置顶</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入URL到网页呈现的过程</title>
    <url>/2021/03/15/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BD%91%E9%A1%B5%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<ul>
<li>1、输入网址</li>
<li>2、DNS解析</li>
<li>3、建立tcp连接</li>
<li>4、客户端发送HTPP请求</li>
<li>5、服务器处理请求</li>
<li>6、服务器响应请求</li>
<li>7、浏览器展示HTML</li>
<li>8、浏览器发送请求获取其他在HTML中的资源。</li>
</ul>
<span id="more"></span>

<h4 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1.域名解析"></a>1.域名解析</h4><p>当我们在浏览器中输入一个URL的时候首先需要解析为IP地址，这一过程叫做DNS解析</p>
<p>DNS解析是一个递归查询的过程，例如我们解析“<a href="http://www.baidu.com”/">www.baidu.com”</a>    时过程是这样的：</p>
<ul>
<li>在本地域名服务器中查询IP地址，未找到域名</li>
<li>本地域名服务器向根域名服务器发送请求，未找到域名</li>
<li>本地服务器向.com顶级域名服务器发送请求，未找到域名</li>
<li>本地域名服务器向.baidu.com域名服务器发送请求，找到该域名，并将对应的IP返回给本地域名服务器</li>
</ul>
<h4 id="2-TCP连接"><a href="#2-TCP连接" class="headerlink" title="2.TCP连接"></a>2.TCP连接</h4><p>HTTP协议是使用TCP协议作为其传输层协议的，在拿到服务器的IP地址后，浏览器客户端会与服务器建立TCP连接，该过程包括<a href="https://3xiaoxiao3.github.io/2021/03/14/TCP%E5%92%8CUDP/#more">三次握手</a> </p>
<h4 id="3-浏览器发送HTTP请求"><a href="#3-浏览器发送HTTP请求" class="headerlink" title="3.浏览器发送HTTP请求"></a>3.浏览器发送HTTP请求</h4><p>浏览器构建http请求报文，并通过TCP协议传送到服务器的指定端口，http请求报文一共包括三个部分：</p>
<ul>
<li>请求行：指定http请求的方法、url、http协议版本等</li>
<li>请求头：描述浏览器的相关信息，语言、编码等</li>
<li>请求正文：当发送POST、PUT等请求时，通常需要向服务器传递数据。这些数据就储存在请求正文中。</li>
</ul>
<h4 id="4-服务器处理HTTP请求"><a href="#4-服务器处理HTTP请求" class="headerlink" title="4.服务器处理HTTP请求"></a>4.服务器处理HTTP请求</h4><p>服务器处理HTTP请求，并返回响应报文。响应报文包括三个部分：</p>
<ul>
<li>状态码：http服务常用的状态码及其含义如下</li>
</ul>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<ul>
<li>响应头：包含了响应的相关信息，如日期等。</li>
<li>响应正文：服务器返回给浏览器的文本信息，通常的 html、js、css、图片等就在这部分里。</li>
</ul>
<h4 id="5-浏览器页面渲染"><a href="#5-浏览器页面渲染" class="headerlink" title="5.浏览器页面渲染"></a>5.浏览器页面渲染</h4><p>浏览器接收到http服务器发送过来的响应报文，并开始解析HTML文档，渲染页面。具体的渲染过程包括：构建DOM树、构建渲染树、定位页面元素、绘制页面元素等</p>
<h4 id="6-断开TCP连接"><a href="#6-断开TCP连接" class="headerlink" title="6.断开TCP连接"></a>6.断开TCP连接</h4><p>客户端与服务器四次挥手，断开TCP连接</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP和UDP</title>
    <url>/2021/03/14/TCP%E5%92%8CUDP/</url>
    <content><![CDATA[<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><span id="more"></span>

<ul>
<li>TCP是面向连接的，UDP是面向无连接的。</li>
<li>UDP程序结构较为简单。</li>
<li>TCP是面向字节流的，UDP是基于数据报的。</li>
<li>TCP保证数据正确性，UDP可能丢包。</li>
<li>TCP保证数据顺序，UDP不保证</li>
</ul>
<h4 id="什么是UDP"><a href="#什么是UDP" class="headerlink" title="什么是UDP"></a>什么是UDP</h4><p>UDP的包头：</p>
<p><img src="https://static001.geekbang.org/resource/image/6d/bf/6d1313f51b9dfd7ab454b2cef1cb37bf.jpg" alt="UDP 包头"></p>
<ul>
<li>两个十六位的端口号，分别为源端口和目标端口。</li>
<li>整个数据报文的长度。</li>
<li>整个数据报文的校验和，该字段用于发现头部信息和数据中的错误。</li>
</ul>
<h5 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h5><ul>
<li>沟通简单，不需要大量的数据结构、处理逻辑和包头字段</li>
<li>不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人。</li>
<li>不会根据网络的情况进行拥塞控制，无论是否丢包都会一直发送</li>
</ul>
<p>因此UDP在传输报文时是很高效的</p>
<h4 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h4><p>TCP的包头格式：</p>
<p><img src="https://static001.geekbang.org/resource/image/a7/bf/a795461effcce686a43f48e094c9adbf.jpg" alt="TCP 包头"></p>
<ul>
<li>首先是源端口和目标端口</li>
<li>接下来是包的序号，主要为了解决乱序问题</li>
<li>确认序号，发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，解决丢包的问题</li>
<li>状态位。SYN是发起一个链接，ACK是回复，RST是重新连接，FIN是结束连接。因为TCP是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更。</li>
<li>窗口大小，TCP要做流量控制，需要通信双方各声明一个窗口，标记自己当前的处理能力</li>
</ul>
<h5 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h5><ol>
<li><p>主机A通过向主机B发送一个含有同步序列号标志位的数据段（SYN）给主机B，向主机B请求建立连接，通过这个数据段，主机A告诉主机B两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。</p>
</li>
<li><p>主机B收到主机A的请求后，用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用哪个序列号作为起始数据段来回应我。</p>
</li>
<li><p>主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B的数据段</p>
<p>这样三次握手就完成了，主机AB就可以传输数据了</p>
</li>
</ol>
<h5 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h5><ol>
<li>当主机A完成数据传输后，将控制位FIN置为1，提出停止TCP连接的请求</li>
<li>主机B收到FIN后对其作出响应，确认这一方向的TCP连接将关闭，将ACK置为1</li>
<li>由主机B端再提出反方向的关闭请求，将FIN置为1</li>
<li>主机A队主机B的请求进行确认，将ACK置为1，双方向的关闭结束</li>
</ol>
<h4 id="TCP的三次握手目的是什么？为什么不用两次和四次？"><a href="#TCP的三次握手目的是什么？为什么不用两次和四次？" class="headerlink" title="TCP的三次握手目的是什么？为什么不用两次和四次？"></a>TCP的三次握手目的是什么？为什么不用两次和四次？</h4><p><strong>TCP 三次握手的主要目的是防止失效的连接请求报文被服务端接受</strong></p>
<p>  如果只有两次握手，假设当客户端发送第一次连接请求由于网络拥塞的原因，迟迟未到服务端，客户端没接收到确认报文，认为服务端没有收到，于是重新发送请求报文并与服务端建立连接，等这次连接断开了，之前滞留的那个请求报文又到达了服务端，就会让服务端与客户端再次连接成功，这时服务端就会一直等待客户端发送请求，造成了资源的浪费。</p>
<p>  两次握手只能保证单向链路是可以通信的，理论上来说，要保证双向链路可以通信需要四次握手，但实际上服务端给客户端的 SYN 和 ACK 数据包可以合为一次握手，所以实际上只需要三次握手即可。</p>
<h4 id="挥手为什么需要四次？三次不行吗？"><a href="#挥手为什么需要四次？三次不行吗？" class="headerlink" title="挥手为什么需要四次？三次不行吗？"></a>挥手为什么需要四次？三次不行吗？</h4><p>挥手阶段中服务端的 ACK 和 FIN 数据包不能合为一次。因为挥手阶段的流程为客户端发送FIN数据包表示自己发完了，服务端立即回复 ACK 数据包表示自己知道了，此时客户端到服务端的连接已经释放了，客户端不会再发送数据了，但服务端还可以继续向客户端发送数据，等到服务端也完成了数据发送，才会发送 FIN，这时客户端回复 ACK，就可以结束通信了。</p>
<h4 id="TCP-在四次挥手的过程中为什么客户端最后还要等待-2MSL-Maximum-Segment-Lifetime-？"><a href="#TCP-在四次挥手的过程中为什么客户端最后还要等待-2MSL-Maximum-Segment-Lifetime-？" class="headerlink" title="TCP 在四次挥手的过程中为什么客户端最后还要等待 2MSL(Maximum Segment Lifetime)？"></a>TCP 在四次挥手的过程中为什么客户端最后还要等待 2MSL(Maximum Segment Lifetime)？</h4><p>因为客户端要保证他的 ACK 包顺利到达服务端，如果客户端的ACK数据包丢失，则服务端或重新发送 FIN 包到客户端，而这两个过程的最长时间为 1MSL，加起来为 2MSL，如果 2MSL 后客户端还没有收到服务端重发的 FIN 包，则说明 ACK 包顺利到达，可以关闭连接了。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象和面向过程</title>
    <url>/2021/03/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="什么是面向对象？什么又是面向过程"><a href="#什么是面向对象？什么又是面向过程" class="headerlink" title="什么是面向对象？什么又是面向过程"></a>什么是面向对象？什么又是面向过程</h3><span id="more"></span>

<h4 id="面向对象：——行为化"><a href="#面向对象：——行为化" class="headerlink" title="面向对象：——行为化"></a>面向对象：——行为化</h4><p>面向对象就是把整个需求按照特点、功能划分，将这些存在共性的部分封装成类，创建了对象不是为了完成某一步骤，而是描述某个事物在解决问题的步骤中的行为</p>
<h5 id="面向对象的三个基本特征"><a href="#面向对象的三个基本特征" class="headerlink" title="面向对象的三个基本特征"></a>面向对象的三个基本特征</h5><p>——封装、多态、继承</p>
<ol>
<li><h6 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h6><p>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行隐藏。</p>
</li>
<li><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p>继承是指一种能力：它可以使用现有的类的所有功能，并且在无需重新编写原来类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或者是“派生类”，被继承的类称为“基类”、“父类”或者“超类”。</p>
</li>
<li><h6 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h6><p>多态性是允许你将父对象设置成为和一个或者更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给他的子对象的特性以及不同的方式运作。</p>
<p>一句话理解：允许将子类类型的指针赋值给父类类型的指针。</p>
<p>实现多态有两种方式：覆盖和重载，两种方式的区别在于：<strong>覆盖在运行时决定，重载是在编译时决定，而且覆盖和重载的机制不同。</strong>例如在Java中，重载方法的签名必须不同于原来方法的，但是对于覆盖签名必须相同。</p>
</li>
</ol>
<h4 id="面向过程——步骤化"><a href="#面向过程——步骤化" class="headerlink" title="面向过程——步骤化"></a>面向过程——步骤化</h4><p>面向过程就是分析出实现需求所需要的步骤，通过函数（方法）一步步实现这些步骤，接着依次调用即可。</p>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>
<p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多益网络面试记录</title>
    <url>/2021/03/12/%E5%A4%9A%E7%9B%8A%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>多益网络一面面试问题记录</p>
<span id="more"></span>

<ol>
<li><p>什么是面向对象？面向对象和面向过程有什么区别？</p>
<p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>
<p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
</li>
<li><p>ArrayList和LinkedList有什么区别？</p>
<p>ArrayList是Array(动态数组)的数据结构，LinkedList是Link(链表)的数据结构。</p>
<p>当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p>当对数据进行增加和删除的操作(add和remove操作)时，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。</p>
<p>ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</p>
<p>ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。</p>
</li>
<li><p>链表和数组有什么区别？在什么时候应该使用链表/数组？</p>
<p>数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。</p>
</li>
<li><p>HashMap的实现方式，HashMap的底层数据结构是什么？</p>
<p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>
<p>HashMap的底层数据结构是数组+链表</p>
<p>当链表长度大于等于8时会转换为红黑树</p>
</li>
<li><p>算法题：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">Leetcode 141.环形链表</a> 如何判断一个链表是否有环？</p>
<p>快慢指针解决，时间复杂度为O(n)</p>
</li>
<li><p>什么是线程不安全？Java要实现线程安全可以用哪些关键字？</p>
<p>是指不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p>
<p>实现线程安全可以用Lock和synchronized</p>
</li>
<li><p>算法题：<a href="https://leetcode-cn.com/problems/permutations/">Leetcode 46.全排列</a> 给定一个值n，输出1-n数字的全排列</p>
<p>回溯算法解决，时间复杂度：O*(<em>n</em>×*n!)，其中 n为序列的长度</p>
</li>
<li><p>数据库事物的四个基本特性是什么？</p>
</li>
</ol>
<p>原子性、一致性、隔离性、持久性</p>
]]></content>
      <tags>
        <tag>面试记录</tag>
      </tags>
  </entry>
</search>
